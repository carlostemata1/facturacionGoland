import { mergeProps as _mergeProps, Fragment as _Fragment, createVNode as _createVNode } from "vue";
// Styles
import "./VInput.sass"; // Components

import { VIcon } from "../VIcon/index.mjs";
import VInputLabel from "./VInputLabel.mjs"; // Composables

import { makeDensityProps, useDensity } from "../../composables/density.mjs";
import { makeThemeProps, useTheme } from "../../composables/theme.mjs";
import { useBackgroundColor, useTextColor } from "../../composables/color.mjs";
import { useProxiedModel } from "../../composables/proxiedModel.mjs"; // Utilities

import { computed, ref, toRef, watch, watchEffect } from 'vue';
import { convertToUnit, defineComponent, getUid, nullifyTransforms, standardEasing, useRender } from "../../util/index.mjs"; // Types

const allowedVariants = ['underlined', 'outlined', 'filled', 'contained', 'plain'];
export default defineComponent({
  name: 'VInput',
  inheritAttrs: false,
  props: {
    active: Boolean,
    appendIcon: String,
    appendOuterIcon: String,
    bgColor: String,
    color: String,
    hideDetails: [Boolean, String],
    hideSpinButtons: Boolean,
    hint: String,
    id: String,
    label: String,
    loading: Boolean,
    modelValue: null,
    persistentHint: Boolean,
    prependIcon: String,
    prependOuterIcon: String,
    reverse: Boolean,
    singleLine: Boolean,
    variant: {
      type: String,
      default: 'filled',
      validator: v => allowedVariants.includes(v)
    },
    ...makeThemeProps(),
    ...makeDensityProps()
  },
  emits: {
    'update:modelValue': value => true,
    'update:active': value => true,
    'click:prepend-outer': e => e,
    'click:prepend': e => e,
    'click:append': e => e,
    'click:append-outer': e => e
  },

  setup(props, {
    attrs,
    emit,
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      densityClasses
    } = useDensity(props, 'v-input');
    const value = useProxiedModel(props, 'modelValue');
    const isActive = useProxiedModel(props, 'active');
    const uid = getUid();
    const labelRef = ref();
    const floatingLabelRef = ref();
    const controlRef = ref();
    const fieldRef = ref();
    const inputRef = ref();
    const isDirty = computed(() => value.value != null && value.value !== '');
    const isFocused = ref(false);
    const id = computed(() => props.id || `input-${uid}`);
    watchEffect(() => isActive.value = isFocused.value || isDirty.value);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, 'bgColor'));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => {
      return isFocused.value ? props.color : undefined;
    }));
    watch(isActive, val => {
      if (!props.singleLine) {
        const el = labelRef.value.$el;
        const targetEl = floatingLabelRef.value.$el;
        const rect = nullifyTransforms(el);
        const targetRect = targetEl.getBoundingClientRect();
        const x = targetRect.x - rect.x;
        const y = targetRect.y - rect.y - (rect.height / 2 - targetRect.height / 2);
        const targetWidth = targetRect.width / 0.75;
        const width = Math.abs(targetWidth - rect.width) > 1 ? {
          maxWidth: convertToUnit(targetWidth)
        } : undefined;
        const duration = parseFloat(getComputedStyle(el).transitionDuration) * 1000;
        const scale = parseFloat(getComputedStyle(targetEl).getPropertyValue('--v-input-label-scale'));
        el.style.visibility = 'visible';
        targetEl.style.visibility = 'hidden';
        el.animate([{
          transform: 'translate(0)'
        }, {
          transform: `translate(${x}px, ${y}px) scale(${scale})`,
          ...width
        }], {
          duration,
          easing: standardEasing,
          direction: val ? 'normal' : 'reverse'
        }).finished.then(() => {
          el.style.removeProperty('visibility');
          targetEl.style.removeProperty('visibility');
        });
      }
    }, {
      flush: 'post'
    });

    function onMousedown(e) {
      if (e.target !== document.activeElement) {
        e.preventDefault();
      }

      focus();
    }

    function focus() {
      var _inputRef$value;

      (_inputRef$value = inputRef.value) == null ? void 0 : _inputRef$value.focus();
    }

    function blur() {
      var _inputRef$value2;

      (_inputRef$value2 = inputRef.value) == null ? void 0 : _inputRef$value2.blur();
    }

    useRender(() => {
      var _slots$default;

      const isOutlined = props.variant === 'outlined';
      const hasPrepend = slots.prepend || props.prependIcon;
      const hasPrependOuter = slots.prependOuter || props.prependOuterIcon;
      const hasAppend = slots.append || props.appendIcon;
      const hasAppendOuter = slots.appendOuter || props.appendOuterIcon;
      const label = slots.label ? slots.label({
        label: props.label,
        props: {
          for: id.value
        }
      }) : props.label;
      return _createVNode("div", _mergeProps({
        "class": ['v-input', {
          'v-input--prepended': hasPrepend,
          'v-input--appended': hasAppend,
          'v-input--dirty': isActive.value,
          'v-input--focused': isFocused.value,
          'v-input--reverse': props.reverse,
          'v-input--has-background': !!props.bgColor,
          'v-input--single-line': props.singleLine,
          [`v-input--variant-${props.variant}`]: true
        }, themeClasses.value, densityClasses.value, textColorClasses.value],
        "style": [textColorStyles.value]
      }, attrs), [hasPrependOuter && _createVNode("div", {
        "class": "v-input__prepend-outer",
        "onClick": e => emit('click:prepend-outer', e)
      }, [slots.prependOuter ? slots.prependOuter() : _createVNode(VIcon, {
        "icon": props.prependOuterIcon
      }, null, 8, ["icon"])], 8, ["onClick"]), _createVNode("div", {
        "ref": controlRef,
        "class": ['v-input__control', backgroundColorClasses.value],
        "style": backgroundColorStyles.value,
        "onMousedown": onMousedown
      }, [_createVNode("div", {
        "class": "v-input__overlay"
      }, null), hasPrepend && _createVNode("div", {
        "class": "v-input__prepend",
        "onClick": e => emit('click:prepend', e)
      }, [slots.prepend ? slots.prepend() : _createVNode(VIcon, {
        "icon": props.prependIcon
      }, null, 8, ["icon"])], 8, ["onClick"]), _createVNode("div", {
        "class": "v-input__field",
        "ref": fieldRef
      }, [['contained', 'filled'].includes(props.variant) && !props.singleLine && _createVNode(VInputLabel, {
        "ref": floatingLabelRef,
        "floating": true
      }, {
        default: () => [label],
        _: 2
      }, 8, ["floating"]), _createVNode(VInputLabel, {
        "ref": labelRef,
        "for": id.value
      }, {
        default: () => [label],
        _: 2
      }, 8, ["for"]), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
        uid,
        isActive: isActive.value,
        props: {
          id: id.value,
          value: value.value,
          ref: inputRef,
          onFocus: () => isFocused.value = true,
          onBlur: () => isFocused.value = false,
          onInput: e => {
            const el = e.target;
            value.value = el.value;
          },
          onChange: e => {
            const el = e.target;
            if (value.value === el.value) return;
            value.value = el.value;
          }
        }
      })], 512), hasAppend && _createVNode("div", {
        "class": "v-input__append",
        "onClick": e => emit('click:append', e)
      }, [slots.append ? slots.append() : _createVNode(VIcon, {
        "icon": props.appendIcon
      }, null, 8, ["icon"])], 8, ["onClick"]), _createVNode("div", {
        "class": "v-input__outline"
      }, [isOutlined && _createVNode(_Fragment, null, [_createVNode("div", {
        "class": "v-input__outline__start"
      }, null), _createVNode("div", {
        "class": "v-input__outline__notch"
      }, [!props.singleLine && _createVNode(VInputLabel, {
        "ref": floatingLabelRef,
        "floating": true
      }, {
        default: () => [label],
        _: 2
      }, 8, ["floating"])]), _createVNode("div", {
        "class": "v-input__outline__end"
      }, null)]), ['plain', 'underlined'].includes(props.variant) && !props.singleLine && _createVNode(VInputLabel, {
        "ref": floatingLabelRef,
        "floating": true
      }, {
        default: () => [label],
        _: 2
      }, 8, ["floating"])])], 46, ["onMousedown"]), hasAppendOuter && _createVNode("div", {
        "class": "v-input__append-outer",
        "onClick": e => emit('click:append-outer', e)
      }, [slots.appendOuter ? slots.appendOuter() : _createVNode(VIcon, {
        "icon": props.appendOuterIcon
      }, null, 8, ["icon"])], 8, ["onClick"]), slots.details && _createVNode("div", {
        "class": "v-input__details"
      }, [slots.details()])], 16);
    });
    return {
      blur,
      focus,
      value,
      isActive,
      isDirty,
      isFocused
    };
  }

});
//# sourceMappingURL=VInput.mjs.map